<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;zazing.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="Hive表相关介绍存储格式Hive会为每个创建的数据库在HDFS上创建一个目录，该数据库的表会以子目录形式存储，表中的数据会以表目录下的文件形式存储。对于default数据库，默认的缺省数据库没有自己的目录，default数据库下的表默认存放在&#x2F;user&#x2F;hive&#x2F;warehouse目录下。 （1）textfile  textfile为默认格式，存储方式为行存储。数据不做压缩，磁盘开销大，数据">
<meta property="og:type" content="article">
<meta property="og:title" content="Hive基本操作">
<meta property="og:url" content="https://zazing.github.io/2021/08/19/Hive%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="zazing">
<meta property="og:description" content="Hive表相关介绍存储格式Hive会为每个创建的数据库在HDFS上创建一个目录，该数据库的表会以子目录形式存储，表中的数据会以表目录下的文件形式存储。对于default数据库，默认的缺省数据库没有自己的目录，default数据库下的表默认存放在&#x2F;user&#x2F;hive&#x2F;warehouse目录下。 （1）textfile  textfile为默认格式，存储方式为行存储。数据不做压缩，磁盘开销大，数据">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-19T08:16:00.000Z">
<meta property="article:modified_time" content="2022-02-19T03:51:33.232Z">
<meta property="article:author" content="zcding">
<meta property="article:tag" content="大数据">
<meta property="article:tag" content="hive">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zazing.github.io/2021/08/19/Hive%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;zazing.github.io&#x2F;2021&#x2F;08&#x2F;19&#x2F;Hive%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;08&#x2F;19&#x2F;Hive基本操作&#x2F;&quot;,&quot;title&quot;:&quot;Hive基本操作&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Hive基本操作 | zazing</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">zazing</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">博学之，审问之，慎思之，明辨之，笃行之</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hive%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">Hive表相关介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">存储格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDL%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">DDL操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">*创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E8%A1%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">创建内部表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%96%E9%83%A8%E8%A1%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">创建外部表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">创建分区表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8CTAS%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">2.1.4.</span> <span class="nav-text">使用CTAS创建表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">修改表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%90%8D"><span class="nav-number">2.2.1.</span> <span class="nav-text">修改表名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%88%86%E5%8C%BA"><span class="nav-number">2.2.2.</span> <span class="nav-text">修改表分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%88%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">修改表列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">*删除表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DML%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">DML操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.1.</span> <span class="nav-text">数据加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Load%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text">*Load方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#INSERT%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">*INSERT方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84%E6%8F%92%E5%85%A5"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">简单结构插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E6%8F%92%E5%85%A5"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">多重插入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.2.</span> <span class="nav-text">数据查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SELECT"><span class="nav-number">3.2.1.</span> <span class="nav-text">SELECT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">字符函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">数学函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">时间函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">窗口函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">条件函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.6.</span> <span class="nav-text">其他常见函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JOIN"><span class="nav-number">3.2.2.</span> <span class="nav-text">JOIN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.3.</span> <span class="nav-text">集合数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.2.4.</span> <span class="nav-text">正则查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">常见正则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.2.5.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8ESQL%E5%88%B0HiveQL%E5%BA%94%E8%BD%AC%E5%8F%98%E7%9A%84%E4%B9%A0%E6%83%AF"><span class="nav-number">3.2.6.</span> <span class="nav-text">从SQL到HiveQL应转变的习惯</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA"><span class="nav-number">3.3.</span> <span class="nav-text">数据导出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hive%E8%A1%A8%E5%AF%BC"><span class="nav-number">3.3.1.</span> <span class="nav-text">Hive表导</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zcding</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2021/08/19/Hive%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hive基本操作
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-19 16:16:00" itemprop="dateCreated datePublished" datetime="2021-08-19T16:16:00+08:00">2021-08-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-02-19 11:51:33" itemprop="dateModified" datetime="2022-02-19T11:51:33+08:00">2022-02-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <span id="more"></span>

<h2 id="Hive表相关介绍"><a href="#Hive表相关介绍" class="headerlink" title="Hive表相关介绍"></a>Hive表相关介绍</h2><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p>Hive会为每个创建的数据库在HDFS上创建一个目录，该数据库的表会以子目录形式存储，表中的数据会以表目录下的文件形式存储。对于default数据库，默认的缺省数据库没有自己的目录，default数据库下的表默认存放在/user/hive/warehouse目录下。</p>
<p><strong>（1）textfile</strong> </p>
<p>textfile为默认格式，存储方式为行存储。数据不做压缩，磁盘开销大，数据解析开销大。 </p>
<p>（2）SequenceFile </p>
<p>SequenceFile是Hadoop API提供的一种二进制文件支持，其具有使用方便、可分割、可压缩的特点。 </p>
<p>SequenceFile支持三种压缩选择：NONE, RECORD, BLOCK。 Record压缩率低，一般建议使用BLOCK压缩。 </p>
<p>（3）RCFile </p>
<p>一种行列存储相结合的存储方式。 </p>
<p>（4）ORCFile </p>
<p>数据按照行分块，每个块按照列存储，其中每个块都存储有一个索引。hive给出的新格式，属于RCFILE的升级版,性能有大幅度提升,而且数据可以压缩存储,压缩快 快速列存取。 </p>
<p><strong>（5）Parquet</strong> </p>
<p>Parquet也是一种行式存储，同时具有很好的压缩性能；同时可以减少大量的表扫描和反序列化的时间。</p>
<h2 id="DDL操作"><a href="#DDL操作" class="headerlink" title="DDL操作"></a>DDL操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="*创建表"></a>*创建表</h3><h4 id="创建内部表"><a href="#创建内部表" class="headerlink" title="创建内部表"></a>创建内部表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE page_view(</span><br><span class="line">     viewTime INT, </span><br><span class="line">     userid BIGINT,</span><br><span class="line">     page_url STRING, </span><br><span class="line">     referrer_url STRING,</span><br><span class="line">     ip STRING COMMENT &#x27;IP Address of the User&#x27;)</span><br><span class="line"> COMMENT &#x27;This is the page view table&#x27;</span><br><span class="line"> PARTITIONED BY(dt STRING, country STRING)</span><br><span class="line"> ROW FORMAT DELIMITED</span><br><span class="line">   FIELDS TERMINATED BY &#x27;\001&#x27;</span><br><span class="line">   COLLECTION ITEMS TERMINATED BY &#x27;\002&#x27;</span><br><span class="line">   MAP KEYS TERMINATED BY &#x27;\003&#x27;</span><br><span class="line"> STORED AS TEXTFILE;</span><br></pre></td></tr></table></figure>



<h4 id="创建外部表"><a href="#创建外部表" class="headerlink" title="创建外部表"></a>创建外部表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE page_view(</span><br><span class="line">     viewTime INT, </span><br><span class="line">     userid BIGINT,</span><br><span class="line">     page_url STRING, </span><br><span class="line">     referrer_url STRING,</span><br><span class="line">     ip STRING COMMENT &#x27;IP Address of the User&#x27;,</span><br><span class="line">     country STRING COMMENT &#x27;country of origination&#x27;)</span><br><span class="line"> COMMENT &#x27;This is the staging page view table&#x27;</span><br><span class="line"> ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;\054&#x27;</span><br><span class="line"> STORED AS TEXTFILE</span><br><span class="line"> LOCATION &#x27;/user/hadoop/warehouse/page_view&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> student_ptn(</span><br><span class="line">		id <span class="type">int</span>, </span><br><span class="line">		name string, </span><br><span class="line">		sex string, </span><br><span class="line">		age <span class="type">int</span>,</span><br><span class="line">		department string)</span><br><span class="line">partitioned <span class="keyword">by</span> (city string)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;,&quot;</span><br><span class="line">location &quot;/hive/student_ptn&quot;;</span><br></pre></td></tr></table></figure>

<p>分区</p>
<p>分为静态分区、动态分区，主要区别在于静态分区需要手动指定，而动态分区是基于查询参数的位置去推断分区的名称，从而建立分区。总的来说就是，静态分区的列是在编译时期通过用户传递来决定的；动态分区只有在SQL执行时才能确定。</p>
<h4 id="使用CTAS创建表"><a href="#使用CTAS创建表" class="headerlink" title="使用CTAS创建表"></a>使用CTAS创建表</h4><p>作用： 就是从一个查询select创建表结构，包括只复制表结构和复制表结构+数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//复制表结构</span><br><span class="line">create table student_copy like student_ptn;</span><br><span class="line">//复制表结构和数据</span><br><span class="line">create table student_ctas as select * from student where id &lt; 95012;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>如果在table的前面没有加external关键字，那么复制出来的新表。无论如何都是内部表<br>如果在table的前面有加external关键字，那么复制出来的新表。无论如何都是外部表</p>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student rename to new_student;</span><br></pre></td></tr></table></figure>

<h4 id="修改表分区"><a href="#修改表分区" class="headerlink" title="修改表分区"></a>修改表分区</h4><p>修改分区，一般来说，都是指修改分区的数据存储目录。</p>
<p>在添加分区的时候，直接指定当前分区的数据存储目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student_ptn add if not exists partition(city=&#x27;beijing&#x27;) location &#x27;/student_ptn_beijing&#x27;;</span><br></pre></td></tr></table></figure>

<p>修改已经指定好的分区的数据存储目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student_ptn partition (city=&#x27;beijing&#x27;) set location &#x27;/student_ptn_beijing&#x27;;</span><br></pre></td></tr></table></figure>

<p>先的分区文件夹仍存在，但是在往分区添加数据时，只会添加到新的分区目录</p>
<h4 id="修改表列"><a href="#修改表列" class="headerlink" title="修改表列"></a>修改表列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//增加表字段	</span><br><span class="line">alter table new_student add columns (score int);</span><br><span class="line">//修改表字段定义</span><br><span class="line">alter table new_student change name new_name string;</span><br><span class="line">//修改字段分隔符</span><br><span class="line">alter table new_student set serdeproperties(&#x27;field.delim&#x27;=&#x27;\t&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="*删除表"></a>*删除表</h3><p>删除表会移除表的元数据和数据，而HDFS上的数据，如果配置了Trash，会移到.Trash/Current目录下。</p>
<p>删除外部表时，表中的数据不会被删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name;</span><br><span class="line">DROP TABLE IF EXISTS table_name;</span><br></pre></td></tr></table></figure>

<p>从表或者表分区删除所有行，不指定分区，将截断表中的所有分区，也可以一次指定多个分区，截断多个分区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE table_name;</span><br><span class="line">TRUNCATE TABLE table_name PARTITION (dt=&#x27;20080808&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="DML操作"><a href="#DML操作" class="headerlink" title="DML操作"></a>DML操作</h2><h3 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h3><h4 id="Load方式"><a href="#Load方式" class="headerlink" title="*Load方式"></a>*Load方式</h4><p>Hive Load语句不会在加载数据的时候做任何转换工作，而是纯粹的把数据文件复制/移动到Hive表对应的地址。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA [<span class="keyword">LOCAL</span>] INPATH <span class="string">&#x27;filepath&#x27;</span> [OVERWRITE] <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span> (partcol1<span class="operator">=</span>val1,partcol2<span class="operator">=</span>val2 ...)]</span><br></pre></td></tr></table></figure>

<ul>
<li>如果命令中带有LOCAL，说明从本地文件系统加载数据，文件路径可以是相对路径，也可以是绝对路径。在这种情况下，首先将文件从本地复制到hdfs相应的位置，然后移动到hive表格中，这个时候原始数据文件是存在于hive表之下的路径下。这一点我会专门写一篇关于hive外部表的相应博文。</li>
<li>如果命令中没有LOCAL，代表我们的数据是从hdfs中读取文件，这个时候如果我们使用的是内部表，相应的hdfs的原始文件会消失，进入到相应的表格中。</li>
<li>filepath 可以是一个相对路径，也可以是一个绝对路径。可以是一个文件，也可以是一个文件夹目录（这个时候文件夹下的所有文件都会被加载）<br>-命令中如果带有overwirte，代表加载数据之前会清空目标表格，否则就是追加的方式。</li>
</ul>
<h4 id="INSERT方式"><a href="#INSERT方式" class="headerlink" title="*INSERT方式"></a>*INSERT方式</h4><h5 id="简单结构插入"><a href="#简单结构插入" class="headerlink" title="简单结构插入"></a>简单结构插入</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE<span class="operator">/</span><span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span>(partcol1 <span class="operator">=</span> col1,partcol2 <span class="operator">=</span>col2…)] <span class="keyword">SELECT</span> _statement <span class="keyword">FROM</span>  _statement</span><br></pre></td></tr></table></figure>

<p>动态分区插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span>(partcol1 <span class="operator">=</span> col1,partcol2 <span class="operator">=</span><span class="string">&#x27;$&#123;col&#125;&#x27;</span>…)] <span class="keyword">SELECT</span> _statement <span class="keyword">FROM</span>  _statement</span><br></pre></td></tr></table></figure>

<h5 id="多重插入"><a href="#多重插入" class="headerlink" title="多重插入"></a>多重插入</h5><p>多表插入指的是在同一条语句中, 把读取的同一份元数据插入到不同的表中。只需要<strong>扫描一遍元数据</strong>即可完成所有表的插入操作, 效率很高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> t_x</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_dest <span class="keyword">partition</span>(p<span class="operator">=</span>’p1’)</span><br><span class="line"><span class="keyword">select</span> …… <span class="keyword">where</span> …….</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_dest <span class="keyword">partition</span>(p<span class="operator">=</span>’p2’)</span><br><span class="line"><span class="keyword">select</span> …… <span class="keyword">where</span> …….</span><br></pre></td></tr></table></figure>

<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>提供了丰富的SQL查询方式来分析存储在Hadoop 分布式文件系统中的数据，可以将结构化的数据文件映射为一张数据库表，并提供完整的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行，通过自己的SQL 去查询分析需要的内容，这套SQL 简称Hive SQL，使不熟悉mapreduce 的用户很方便的利用SQL 语言查询，汇总，分析数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] select_expr, select_expr, ...</span><br><span class="line"><span class="keyword">FROM</span> table_reference</span><br><span class="line">[<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> col_list [<span class="keyword">HAVING</span> <span class="keyword">condition</span>]]</span><br><span class="line">[CLUSTER <span class="keyword">BY</span> col_list]</span><br><span class="line">[DISTRIBUTE <span class="keyword">BY</span> col_list] [SORT <span class="keyword">BY</span><span class="operator">|</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">[LIMIT number]</span><br></pre></td></tr></table></figure>

<p>•使用ALL和DISTINCT选项区分对重复记录的处理。默认是ALL，表示查询所有记录。DISTINCT表示去掉重复的记录</p>
<p>•Where 条件</p>
<p>•类似我们传统SQL的where 条件</p>
<p>•目前支持 AND,OR ,0.9版本支持between</p>
<p>•IN, NOT IN</p>
<p>•不支持EXIST ,NOT EXIST</p>
<p>ORDER BY与SORT BY的不同</p>
<p>•ORDER BY 全局排序，只有一个Reduce任务</p>
<p>•SORT BY 只在本机做排序</p>
<h5 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h5><p>说明：对字符进行拼接、截取、去空格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">字符串长度函数：        length</span><br><span class="line">字符串反转函数：        reverse</span><br><span class="line">字符串连接函数：        concat;     concat(‘abc’,&#x27;def’,&#x27;gh’)-&gt;abcdefgh</span><br><span class="line">带分隔符字符串连接函数： concat_ws;  concat_ws(&#x27;,&#x27;,&#x27;abc&#x27;,&#x27;def&#x27;,&#x27;gh&#x27;)-&gt;abc,def,gh</span><br><span class="line">字符串截取函数：        substr,substring; substr(&#x27;abcde&#x27;,3); substring(&#x27;abcde&#x27;,3)</span><br><span class="line">字符串截取函数：        substr,substring  substr(&#x27;abcde&#x27;,3,2);substring(&#x27;abcde&#x27;,3,2)</span><br><span class="line">字符串转大写函数：      upper,ucase</span><br><span class="line">字符串转小写函数：      lower,lcase</span><br><span class="line">去空格函数：            trim; 去除字符串两边的空格; trim(&#x27; abc &#x27;)</span><br><span class="line">左边去空格函数：        ltrim</span><br><span class="line">右边去空格函数：        rtrim</span><br><span class="line">正则表达式替换函数：    regexp_replace; regexp_replace(string A, string B, string C); 将字符串A中的符合java正则表达式B的部分替换为C。</span><br><span class="line">							eg: regexp_replace(&#x27;foobar&#x27;, &#x27;oo|ar&#x27;, &#x27;&#x27;)-&gt;fb</span><br><span class="line">正则表达式解析函数：    regexp_extract; regexp_extract(string subject,string pattern,int index);将字符串subject按照pattern正则规则拆分返回index指定字符。</span><br><span class="line">							eg: regexp_extract(&#x27;foothebar&#x27;, &#x27;foo(.*?)(bar)&#x27;, 0)-&gt;foothebar</span><br><span class="line">								regexp_extract(&#x27;foothebar&#x27;, &#x27;foo(.*?)(bar)&#x27;, 1)-&gt;bar</span><br><span class="line">								regexp_extract(data_field,&#x27;.*?bgStart\\=([^&amp;]+)&#x27;,1) </span><br><span class="line">URL解析函数：           parse_url;  parse_url(string urlString, string partToExtract [, string keyToExtract]);</span><br><span class="line">							返回：URL中指定的部分。partToExtract的有效值为：HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO</span><br><span class="line">							eg: parse_url(&#x27;https://www.iteblog.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#x27;, &#x27;HOST&#x27;)-&gt;facebook.com</span><br><span class="line">								parse_url(&#x27;https://www.iteblog.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#x27;, &#x27;QUERY&#x27;, &#x27;k1&#x27;)-&gt;v1	</span><br><span class="line">json解析函数：          get_json_object;get_json_object(string json_string, string path); 解析json的字符串json_string,返回path指定的内容</span><br><span class="line">空格字符串函数：        space;  length(space(10)) -&gt; 10</span><br><span class="line">重复字符串函数：        repeat; repeat(&#x27;abc&#x27;,5)-&gt;abcabcabcabcabc</span><br><span class="line">首字符ascii函数：       ascii;  ascii(&#x27;abcde&#x27;)-&gt;97</span><br><span class="line">左补足函数：            lpad;   lpad(&#x27;abc&#x27;,10,&#x27;td&#x27;)-&gt;tdtdtdtabc</span><br><span class="line">右补足函数：            rpad</span><br><span class="line">分割字符串函数:         split;       split(&#x27;abtcdtef&#x27;,&#x27;t&#x27;)-&gt;[&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]; 返回值: array</span><br><span class="line">集合查找函数:           find_in_set; find_in_set(string str, string strList);  返回str在strlist第一次出现的位置，strlist是用逗号分割的字符串。</span><br><span class="line">							eg: find_in_set(&#x27;ab&#x27;,&#x27;ef,ab,de&#x27;)-&gt; 2</span><br><span class="line">								find_in_set(&#x27;at&#x27;,&#x27;ef,ab,de&#x27;)-&gt; 0</span><br></pre></td></tr></table></figure>



<h5 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">取整函数:         round;   round(double a);        返回值: BIGINT</span><br><span class="line">指定精度取整函数:  round;   round(double a, int d); 返回值: DOUBLE</span><br><span class="line">向下取整函数:     floor;   返回值: BIGINT</span><br><span class="line">向上取整函数:     ceil;    返回值: BIGINT</span><br><span class="line">向上取整函数: 	 ceiling; 与ceil功能相同;   返回值: BIGINT   </span><br><span class="line">                 银行家舍入法（1~4：舍，6~9：进，5-&gt;前位数是偶：舍，5-&gt;前位数是奇：进）；</span><br><span class="line">                 bround(2.5) = 2, bround(3.5) = 4.</span><br><span class="line">取随机数函数:     rand;    rand(),rand(int seed);  返回值: double</span><br><span class="line">自然指数函数:     exp;     返回值: double</span><br><span class="line">以10为底对数函数: log10;   返回值: double</span><br><span class="line">以2为底对数函数:  log2</span><br><span class="line">对数函数:         log;     log(double base, double a)</span><br><span class="line">幂运算函数:       pow;     pow(double a, double p)</span><br><span class="line">幂运算函数:       power;   与pow功能相同</span><br><span class="line">立方根函数:       cbrt(2)</span><br><span class="line">开平方函数:       sqrt</span><br><span class="line">数学常数e         e()</span><br><span class="line">数学常数pi        pi()</span><br><span class="line">阶乘函数:         factorial(2)</span><br><span class="line">二进制函数:       bin;   返回值: string  </span><br><span class="line">十六进制函数:     hex;   返回值: string</span><br><span class="line">反转十六进制函数: unhex</span><br><span class="line">进制转换函数:     conv</span><br><span class="line">绝对值函数:       abs;  返回值: double int</span><br><span class="line">正取余函数:       pmod; pmod(int a, int b),pmod(double a, double b); 返回值: int double</span><br><span class="line">正弦函数:         sin</span><br><span class="line">反正弦函数:       asin</span><br><span class="line">余弦函数:         cos</span><br><span class="line">反余弦函数:       acos</span><br><span class="line">正切值函数:       tan</span><br><span class="line">反正切值函数:     atan</span><br><span class="line">弧度值转换角度值: degrees(30)</span><br><span class="line">角度值转换弧度值: radians(30)</span><br><span class="line">符号函数：        sign(2); 如果a是正数则返回1.0，是负数则返回-1.</span><br><span class="line">positive函数:     positive; positive(int a), positive(double a); 返回值: int double,返回a</span><br><span class="line">negative函数:     negative; negative(int a), negative(double a); 返回值: int double,返回-a</span><br></pre></td></tr></table></figure>

<h5 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h5><p>说明：时间获取、格式化、2个时间相差、时间增加、时间减少</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UNIX时间戳转日期函数:       from_unixtime; 返回值:string;  from_unixtime(1323308943,&#x27;yyyyMMdd&#x27;)</span><br><span class="line">获取当前UNIX时间戳函数: 	   unix_timestamp;返回值: bigint; unix_timestamp()</span><br><span class="line">日期转UNIX时间戳函数:        unix_timestamp;返回值: bigint; unix_timestamp(&#x27;2011-12-07 13:01:03&#x27;)</span><br><span class="line">指定格式日期转UNIX时间戳函数: unix_timestamp;返回值: bigint; unix_timestamp(&#x27;20111207 13:01:03&#x27;,&#x27;yyyyMMdd HH:mm:ss&#x27;)</span><br><span class="line">日期时间转日期函数:         to_date;    返回值: string; to_date(&#x27;2011-12-08 10:03:01&#x27;)</span><br><span class="line">日期转年函数:               year;       返回值: int;    year(&#x27;2011-12-08 10:03:01&#x27;)</span><br><span class="line">日期转月函数:               month    </span><br><span class="line">日期转天函数:               day      </span><br><span class="line">日期转小时函数:             hour     </span><br><span class="line">日期转分钟函数:             minute   </span><br><span class="line">日期转秒函数:               second   </span><br><span class="line">日期转周函数:               weekofyear; 返回值: int;    weekofyear(&#x27;2019-01-01 10:03:01&#x27;);   返回日期在当前的周数。</span><br><span class="line">日期转天函数:               dayofmonth; 返回值: int;    weekofyear(&#x27;2019-01-01 10:03:01&#x27;);   返回日期在当前月的天数</span><br><span class="line">日期比较函数:               datediff;   返回值: int;    datediff(&#x27;2012-12-08&#x27;,&#x27;2012-05-09&#x27;); 返回结束日期减去开始日期的天数。</span><br><span class="line">日期增加函数:               date_add;   返回值: string; date_add(&#x27;2012-12-08&#x27;,10);           返回开始日期startdate增加days天后的日期。</span><br><span class="line">日期减少函数:               date_sub</span><br><span class="line">最后一天的日期：            last_day</span><br><span class="line">返回当前时间的下一个星期X所对应的日期: next_day(&#x27;2015-01-14&#x27;, &#x27;TU&#x27;) = 2015-01-20  以2015-01-14为开始时间，其下一个星期二所对应的日期为2015-01-20</span><br><span class="line">返回当前时间属性哪个季度： quarter(&#x27;2015-04-08&#x27;) = 2</span><br><span class="line">返回当前时间日期:         current_date</span><br><span class="line">返回当前时间戳:           current_timestamp</span><br><span class="line">添加月数：                add_months(&#x27;2017-02-10&#x27;, 2);</span><br></pre></td></tr></table></figure>

<h5 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h5><p> • 窗口函数与分析函数:<br>    •用于分区排序<br>    •动态Group By<br>    •Top N<br>    •累计计算<br>    •层次查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">•排序函数：</span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，相同值取不同序号，不存在序号跳跃</span><br><span class="line">	  <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，相同值取相同序号，存在序号跳跃，不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，相同值取相同序号，不存在序号跳跃，不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"></span><br><span class="line">•聚合函数：</span><br><span class="line"><span class="built_in">sum</span>()<span class="operator">/</span><span class="built_in">count</span>()<span class="operator">/</span><span class="built_in">max</span>()<span class="operator">/</span><span class="built_in">max</span>()<span class="operator">/</span><span class="built_in">min</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..)：取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，聚合函数计算</span><br><span class="line"></span><br><span class="line">•窗口函数：</span><br><span class="line"><span class="built_in">lag</span>(col,n,<span class="keyword">default</span>)    <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..)：取<span class="keyword">partition</span>分组后，查看当前行的上第n行,不指定<span class="keyword">default</span>为<span class="keyword">null</span>,指定为指定字段，不支持<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">lead</span>(col,n,<span class="keyword">default</span>)   <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..)：取<span class="keyword">partition</span>分组后，查看当前行的下第n行,不指定<span class="keyword">default</span>为<span class="keyword">null</span>,指定为指定字段，不支持<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">first_value</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，截止到当前行<span class="operator">|</span>所有行，第一个值 </span><br><span class="line"><span class="built_in">last_value</span>()  <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，截止到当前行<span class="operator">|</span>所有行，最后一个值  </span><br><span class="line"></span><br><span class="line">•其他函数</span><br><span class="line"><span class="built_in">cume_dist</span>()  计算结果相对位置<span class="operator">/</span>总行数,不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">percent_rank</span>() (相对位置<span class="number">-1</span>)<span class="operator">/</span>(总行数<span class="number">-1</span>),不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">percentile_disc</span>()</span><br><span class="line">percentile_count()</span><br><span class="line">ratio_to_report() 计算当前行在分组中所有行数值总和所占的比例</span><br><span class="line"><span class="built_in">ntile</span>(n)      <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，照顺序切分成n片，返回当前切片值，不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"></span><br><span class="line">•<span class="keyword">over</span>从句：使用<span class="keyword">partition</span> <span class="keyword">by</span>与<span class="keyword">order</span> <span class="keyword">by</span>语句，使用一个或者多个数据类型的分区或者排序列 </span><br><span class="line">注:<span class="keyword">partition</span>内更细的划分，可使用windows子句。常见子句为：</span><br><span class="line">			preceding：  往前</span><br><span class="line">			following：  往后</span><br><span class="line">			<span class="keyword">current</span> <span class="type">row</span>：当前行</span><br><span class="line">			unbounded：  无界限（起点或终点）</span><br><span class="line">			unbounded preceding：表示从前面的起点</span><br><span class="line">			unbounded following：表示到后面的终点</span><br><span class="line">	eg: <span class="built_in">sum</span>(col) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> .. <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>):当前行与前一行做聚合</span><br><span class="line"></span><br><span class="line">•窗口规范支持以下格式：窗口必须和<span class="keyword">order</span> <span class="keyword">by</span> 一起出现</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> [unbounded <span class="operator">|</span> num] preceding <span class="keyword">and</span> [unbounded <span class="operator">|</span> num] following  <span class="comment">--当前行+往前所有行|num行+往后所有行|num行</span></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> [unbounded <span class="operator">|</span> num] preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>                  <span class="comment">--当前行+往前所有行|num行</span></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span>                 <span class="keyword">and</span> [unbounded <span class="operator">|</span> num] following  <span class="comment">--当前行+往后所有行|num行</span></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> [unbounded <span class="operator">|</span> num] preceding <span class="keyword">and</span> [num] preceding</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> [num] following <span class="keyword">and</span> [unbounded <span class="operator">|</span> num] following</span><br><span class="line"></span><br><span class="line">• <span class="keyword">order</span> <span class="keyword">by</span> 后面缺少窗口<span class="keyword">rows</span>从句条件，</span><br><span class="line">   窗口规范默认是 <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span></span><br><span class="line">• <span class="keyword">order</span> <span class="keyword">by</span> 和窗口<span class="keyword">rows</span>从句都缺失,    </span><br><span class="line">   窗口规范默认是 <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> unbounded following</span><br><span class="line">• <span class="keyword">over</span> 从句支持排序函数、lead、lag、<span class="built_in">ntile</span>(n) 函数，但是并不支持和窗口一起使用它们</span><br></pre></td></tr></table></figure>

<h5 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">If函数:      if; if(1=2,100,200)</span><br><span class="line">非空查找函数: COALESCE;  COALESCE(null,&#x27;100&#x27;,&#x27;50&#x27;)</span><br><span class="line">非空查找函数: NVL;       NVL(expr1,expr2)</span><br><span class="line">非空查找函数: NVL2;      NVL2(expr1,expr2, expr3); 第一个参数为空那么显示第二个参数的值，如果第一个参数的值不为空，则显示第三个参数的值。</span><br><span class="line">非空查找函数: NULLIF;    NULLIF(exp1,expr2);      如果exp1和exp2相等则返回空(NULL)，否则返回第一个值</span><br><span class="line">条件判断函数：CASE val when num1 then &#x27;str&#x27; end; case 100 when 50 then &#x27;tom&#x27; when 100 then &#x27;mary&#x27; else &#x27;tim&#x27; end</span><br><span class="line">条件判断函数：CASE when val=num1 then &#x27;str&#x27; end; case when 1=2 then &#x27;tom&#x27; when 2=2 then &#x27;mary&#x27; else &#x27;tim&#x27; end</span><br></pre></td></tr></table></figure>

<h5 id="其他常见函数"><a href="#其他常见函数" class="headerlink" title="其他常见函数"></a>其他常见函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">• explode函数: (一行转多行)将字段内复杂的数据拆分成多行, 常用来做行拆多行</span><br><span class="line">				eg: explode(array): 返回多行array中对应的元素。如explode(array(&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;)),返回:A\B\C三行</span><br><span class="line">					explode(map): 返回多行map键值对对应元素。如explode(map(1,&#x27;A&#x27;,2,&#x27;B&#x27;,3,&#x27;C&#x27;)),返回:</span><br><span class="line"></span><br><span class="line">• lateral view函数：(一行转多行)当表中某个字段的取值为列表或数组时，利用该函数和split、explode可以将一行拆分成多行</span><br><span class="line">				eg: select deal_id ,type ,sp </span><br><span class="line">					from deal_ppt_mark_log t </span><br><span class="line">					lateral view explode(split(t.sources,&#x27;,&#x27;))a as sp</span><br><span class="line">				行转多列可以认为多列是一个字段处理，多个转换之间lateral view不能有 &quot;，&quot; 分割开</span><br><span class="line">				SELECT MR_Longitude,MR_Latitude,b,MAX(a) </span><br><span class="line">				FROM</span><br><span class="line">				(</span><br><span class="line">					select a,b,</span><br><span class="line">						MR_Longitude * 360 *1.0/ 16777216 MR_Longitude,</span><br><span class="line">						MR_Latitude * 90 / 8388608 MR_Latitude</span><br><span class="line">					FROM etl_4g_mro_zte </span><br><span class="line">					lateral view explode(split(concat_ws(&#x27;,&#x27;,MR_LteScRSRP,MR_LteNcRSRP1,MR_LteNcRSRP2,),&#x27;,&#x27;)) r1 AS a             </span><br><span class="line">					-----没有&#x27;,&#x27;</span><br><span class="line">					lateral view explode(split(concat_ws(&#x27;,&#x27;,MR_LteScEarfcn,MR_LteNcEarfcn1,MR_LteNcEarfcn2),&#x27;,&#x27;)) f1 AS b</span><br><span class="line">				)</span><br><span class="line">				WHERE MR_Longitude IS NOT NULL </span><br><span class="line">				AND MR_Longitude &lt;&gt;&#x27;&#x27;</span><br><span class="line">				AND DAY=20170323;</span><br><span class="line">			</span><br><span class="line">• collect_set()/Collect_list()函数：(多行转一行),同组不同行合并成一行，collect_set/collect_set 去重/不去重，</span><br><span class="line">                                 常常搭配concat_ws()函数使用</span><br><span class="line">				eg: concat_ws(&#x27;,&#x27;,collect_list(cast(qty as string)))	</span><br><span class="line"></span><br><span class="line">• str_to_map函数：str_to_map(字符串参数, 分隔符1, 分隔符2),分隔符1将文本分成K-V对，分隔符2分割每个K-V对。</span><br><span class="line">				eg: str_to_map(concat_ws(&#x27;,&#x27;,collect_set(concat(stat_date,&#x27;:&#x27;,label_state))),&#x27;,&#x27;,&#x27;:&#x27;) </span><br><span class="line"></span><br><span class="line">• distribute by和sort by函数一起使用：ditribute by是控制map的输出在reducer是如何划分的</span><br><span class="line">				eg: select mid, money, name from store distribute by mid sort by mid asc, money asc;</span><br><span class="line">				    所有的mid相同的数据会被送到同一个reducer去处理，这就是因为指定了distribute by mid</span><br><span class="line">					distribute by必须要写在sort by之前</span><br><span class="line"></span><br><span class="line">• cluster by函数： cluster by的功能就是distribute by和sort by相结合</span><br><span class="line">				eg: select mid, money, name from store cluster by mid sort by money;</span><br><span class="line">				    注意被cluster by指定的列只能是降序，不能指定asc和desc。</span><br><span class="line"></span><br><span class="line">• grouping sets()/cube()/rollup()高级聚合函数:</span><br></pre></td></tr></table></figure>



<h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h4><p>Hive 只支持等值连接（equality joins）、外连接（outer joins）和（left semi joins）。 Hive 不支持所有非等值的连接，因为非等值连接非常难转化到 map/reduce 任务 </p>
<ul>
<li><p>LEFT，RIGHT和FULL OUTER关键字用于处理join中空记录的情况 </p>
</li>
<li><p>LEFT SEMI JOIN 是 IN/EXISTS 子查询的一种更高效的实现 </p>
</li>
<li><p>join 时，每次 map/reduce 任务的逻辑是这样的： reducer会缓存join序列中除了最后一个表的所有表的记录，再通过最后一个表将结果序列化到文件系统 </p>
</li>
<li><p>实践中，应该把最大的那个表写在最后</p>
</li>
</ul>
<p><strong>LEFT SEMI JOIN</strong></p>
<p>LEFT SEMI JOIN 的限制是，JOIN 子句中右边的表只能在 ON 子句中设置过滤条件，在 WHERE 子句、SELECT 子句或其他地方过滤都不行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.key, a.value </span><br><span class="line"> <span class="keyword">FROM</span> a </span><br><span class="line"> <span class="keyword">WHERE</span> a.key <span class="keyword">in</span> (<span class="keyword">SELECT</span> b.key <span class="keyword">FROM</span> B);</span><br><span class="line">可以被重写为：</span><br><span class="line"> <span class="keyword">SELECT</span> a.key, a.val </span><br><span class="line"> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> SEMI <span class="keyword">JOIN</span> b <span class="keyword">on</span> (a.key <span class="operator">=</span> b.key)</span><br></pre></td></tr></table></figure>

<p><strong>UNION ALL</strong></p>
<p>用来合并多个select的查询结果，需要保证select中字段须一致  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_statement <span class="keyword">UNION</span> <span class="keyword">ALL</span> select_statement <span class="keyword">UNION</span> <span class="keyword">ALL</span> select_statement ...</span><br></pre></td></tr></table></figure>

<h4 id="集合数据结构"><a href="#集合数据结构" class="headerlink" title="集合数据结构"></a>集合数据结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">•数组类型：array， 存放相同类型的数据集合，        如：array[int] 下标访问 </span><br><span class="line">•映射集合类型：map， 存放相同类型的k-v键值对集合，   如：members[&quot;father&quot;],map_keys(members),map_values(members)</span><br><span class="line">•结构体类型： struct，可存放不同类型的数据的集合，    如：struct&#123;name:STRING,age:INT&#125;.</span><br></pre></td></tr></table></figure>

<p>如本身数据以string格式存储，但内容为json格式，可使用get_json_object</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_json_object(param1,&quot;$.param2&quot;)</span><br><span class="line">#第一个参数填写json对象变量，第二个参数使用$表示json变量标识，然后用 . 或 [] 读取对象或数组；如果输入的json字符串无效，那么返回NULL。</span><br><span class="line">json_tuple(jsonstr,p1,p2,……pn)</span><br><span class="line">#json_tuple与get_json_object的用法很类似，唯一的区别是，json_tuple输入的是json字符串中的多个&quot;字段&quot;，返回一个元组，元组中的所有数据类型为string。</span><br></pre></td></tr></table></figure>



<h4 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h4><table>
<thead>
<tr>
<th>/</th>
<th>做为转义，即通常在”/“后面的字符不按原来意义解释，如/b/匹配字符”b”，当b前面加了反斜杆后//b/，转意为匹配一个单词的边界。对正则表达式功能字符的还原，如”<em>“匹配它前面元字符0次或多次，/a</em>/将匹配a,aa,aaa，加了”/“后，/a/<em>/将只匹配”a</em>“。</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配一个输入或一行的开头，/^a/匹配”an A”，而不匹配”An a”</td>
</tr>
<tr>
<td>$</td>
<td>匹配一个输入或一行的结尾，/a$/匹配”An a”，而不匹配”an A”</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa ?    匹配前面元字符0次或1次，/ba*</td>
</tr>
<tr>
<td>(x)</td>
<td>匹配x保存x在名为$1…$9的变量中</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配x或y</td>
</tr>
<tr>
<td>{n}</td>
<td>精确匹配n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配n次以上</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配n-m次[xyz]    字符集(character set)，匹配这个集合中的任一一个字符(或元字符)</td>
</tr>
<tr>
<td>[xyz]</td>
<td>匹配这个集合中的任意一个字符或元字符，[ ^xyz]表示不匹配这个集合中的任何一个字符</td>
</tr>
<tr>
<td>[/b]</td>
<td>匹配一个退格符</td>
</tr>
<tr>
<td>/b</td>
<td>匹配一个单词的边界</td>
</tr>
<tr>
<td>/B</td>
<td>匹配一个单词的非边界</td>
</tr>
<tr>
<td>/cX</td>
<td>这儿，X是一个控制符，//cM/匹配Ctrl-M</td>
</tr>
<tr>
<td>/d</td>
<td>匹配一个字数字符，//d/ = /[0-9]/</td>
</tr>
<tr>
<td>/D</td>
<td>匹配一个非字数字符，//D/ = /[^0-9]/</td>
</tr>
<tr>
<td>/n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>/r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td>/s</td>
<td>匹配一个空白字符，包括/n,/r,/f,/t,/v</td>
</tr>
<tr>
<td>/S</td>
<td>匹配一个非空白字符，等于/[^/n/f/r/t/v]/</td>
</tr>
<tr>
<td>/t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td>/v</td>
<td>匹配一个重直制表符</td>
</tr>
<tr>
<td>/w</td>
<td>匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[/w]匹配”$5.98”中的5，等于[a-zA-Z0-9]</td>
</tr>
<tr>
<td>/W</td>
<td>匹配一个不可以组成单词的字符，如[/W]匹配”$5.98”中的$，等于[^a-zA-Z0-9]</td>
</tr>
</tbody></table>
<h5 id="常见正则"><a href="#常见正则" class="headerlink" title="常见正则"></a>常见正则</h5><p><strong>日期相关</strong></p>
<p>日期格式：^\d{4}-\d{1,2}-\d{1,2}</p>
<p>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p>
<p>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p>
<p><strong>汉字</strong></p>
<p> 汉字：^[\u4e00-\u9fa5]{0,}$</p>
<p><strong>金额</strong></p>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="从SQL到HiveQL应转变的习惯"><a href="#从SQL到HiveQL应转变的习惯" class="headerlink" title="从SQL到HiveQL应转变的习惯"></a>从SQL到HiveQL应转变的习惯</h4><p>1、Hive不支持等值连接</p>
<p>SQL中对两表内联可以写成：</p>
<p>select * from dual a,dual b where a.key = b.key;</p>
<p>Hive中应为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dual a <span class="keyword">join</span> dual b <span class="keyword">on</span> a.key <span class="operator">=</span> b.key;</span><br></pre></td></tr></table></figure>

<p>而不是传统的格式：</p>
<p>SELECT t1.a1 as c1, t2.b1 as c2FROM t1, t2</p>
<p>WHERE t1.a2 = t2.b2</p>
<p>2、分号字符</p>
<p>分号是SQL语句结束标记，在HiveQL中也是，但是在HiveQL中，对分号的识别没有那么智慧，例如：</p>
<p><code>select concat(key,concat(&#39;;&#39;,key)) from dual;</code></p>
<p>但HiveQL在解析语句时提示：</p>
<p>FAILED: Parse Error: line 0:-1 mismatched input ‘<EOF>‘ expecting ) in function specification</EOF></p>
<p>解决的办法是，使用分号的八进制的ASCII码进行转义，那么上述语句应写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(key,concat(<span class="string">&#x27;\073&#x27;</span>,key)) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p><strong>3、IS [NOT] NULL</strong></p>
<p>SQL中null代表空值, 值得警惕的是, 在HiveQL中String类型的字段若是空(empty)字符串, 即长度为0, 那么对它进行IS NULL的判断结果是False，可以 使用如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> length(filed) <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>4、Hive不支持将数据插入现有的表或分区中，仅支持覆盖重写整个表，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> t1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2;</span><br></pre></td></tr></table></figure>

<p>5、Hive 的嵌套查询再必须给表起别名</p>
<p>如：          </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.column <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> dt <span class="operator">=</span> <span class="number">20180528</span>) a   <span class="keyword">group</span> <span class="keyword">by</span>   a.dt limit <span class="number">100</span>        </span><br></pre></td></tr></table></figure>

<p>6、当有两个分区时，在使用where语句查询的时候，必须将两个分区都写出来，如：</p>
<p>若表的分区有两个dt日期和hr小时，我们想选择20180608这一个分区的数据，则选择条件为where dt = 20180608 and hr&gt;= 0 </p>
<h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><h4 id="Hive表导"><a href="#Hive表导" class="headerlink" title="Hive表导"></a>Hive表导</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE [<span class="keyword">LOCAL</span>] DIRECTORY <span class="string">&#x27;/home/hadoop/output&#x27;</span> <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> testA;  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 直接执行sql</span><br><span class="line">./hive -e &quot;select * from testA&quot; &gt;&gt; /home/hadoop/output/testA.txt</span><br><span class="line"># 执行sql文件</span><br><span class="line">./hive -f /home/hadoop/output/sql.sql &gt;&gt; /home/hadoop/output/testB.txt  </span><br></pre></td></tr></table></figure>




    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag"># 大数据</a>
              <a href="/tags/hive/" rel="tag"># hive</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5/" rel="prev" title="自动化测试平台实践">
                  <i class="fa fa-chevron-left"></i> 自动化测试平台实践
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/19/%E8%B4%A8%E9%87%8F%E5%BA%A6%E9%87%8F%E4%B9%8B%E2%80%98%E4%B8%89%E7%BA%A7%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB%E2%80%99/" rel="next" title="质量度量之'三级指标体系'">
                  质量度量之'三级指标体系' <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zcding</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
