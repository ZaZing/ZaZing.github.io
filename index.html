<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;zazing.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="zazing">
<meta property="og:url" content="https://zazing.github.io/index.html">
<meta property="og:site_name" content="zazing">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zcding">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zazing.github.io/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>zazing</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">zazing</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">博学之，审问之，慎思之，明辨之，笃行之</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zcding</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2022/01/13/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B9%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/13/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B9%96/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-13 20:33:04 / 修改时间：20:31:54" itemprop="dateCreated datePublished" datetime="2022-01-13T20:33:04+08:00">2022-01-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="大数据的发展历史"><a href="#大数据的发展历史" class="headerlink" title="大数据的发展历史"></a>大数据的发展历史</h1><h2 id="启蒙时代：数据仓库的出现"><a href="#启蒙时代：数据仓库的出现" class="headerlink" title="启蒙时代：数据仓库的出现"></a>启蒙时代：数据仓库的出现</h2><h2 id="技术革命：从Hadoop到数据湖"><a href="#技术革命：从Hadoop到数据湖" class="headerlink" title="技术革命：从Hadoop到数据湖"></a>技术革命：从Hadoop到数据湖</h2><h2 id="数据工厂时代：大数据平台兴起"><a href="#数据工厂时代：大数据平台兴起" class="headerlink" title="数据工厂时代：大数据平台兴起"></a>数据工厂时代：大数据平台兴起</h2><h4 id="一、数据湖的定义"><a href="#一、数据湖的定义" class="headerlink" title="一、数据湖的定义"></a><strong>一、数据湖的定义</strong></h4><p>维基百科上定义，数据湖（Data Lake）是一个以原始格式存储数据的存储库或系统。它按原样存储数据，而无需事先对数据进行结构化处理。一个数据湖可以存储结构化数据（如关系型数据库中的表），半结构化数据（如CSV、日志、XML、JSON），非结构化数据（如电子邮件、文档、PDF）和二进制数据（如图形、音频、视频）。</p>
<p>但是随着大数据技术的融合发展，数据湖不断演变，汇集了各种技术，包括数据仓库、实时和高速数据流技术、数据挖掘、深度学习、分布式存储和其他技术。逐渐发展成为一个可以存储所有结构化和非结构化任意规模数据，并可以运行不同类型的大数据工具，对数据进行大数据处理、实时分析和机器学习等操作的统一数据管理平台。</p>
<h4 id="二、数据中台的定义"><a href="#二、数据中台的定义" class="headerlink" title="二、数据中台的定义"></a><strong>二、数据中台的定义</strong></h4><p>2016年，阿里巴巴率先提出来“数据中台”的口号，通俗来讲，数据中台是一套可持续“让企业的数据用起来”的机制，一种战略选择和组织形式，是依据企业特有的业务模式和组织架构，通过有形的产品和实施方法论支撑，构建一套持续不断把数据变成资产并服务于业务的机制。数据中台的核心，是避免数据的重复计算，通过数据服务化，提高数据的共享能力，赋能应用数据。</p>
<h4 id="三、数据湖与数据中台的关系，数据湖和数据中台的区别"><a href="#三、数据湖与数据中台的关系，数据湖和数据中台的区别" class="headerlink" title="三、数据湖与数据中台的关系，数据湖和数据中台的区别"></a><strong>三、数据湖与数据中台的关系，数据湖和数据中台的区别</strong></h4><p>大数据时代，数据量越来越多，数据形式日益复杂，而以数据仓库为代表的、现有的数据存储和处理技术无法满足海量、多样的数据处理需求的背景下产生的。“数据湖”是将复杂的事物具象化，偏技术一些，以一个形象的名字，反应了它在大数据存储和大数据处理方面的优势和能力。</p>
<p>数据湖作为一个集中的存储库，可以在其中存储任何形式（结构化和非结构化）、任意规模的数据。在数据湖中，可以不对存储的数据进行结构化，只有在使用数据的时候，再利用数据湖强大的大数据查询、处理、分析等组件对数据进行处理和应用。因此，数据湖具备运行不同类型数据分析的能力。</p>
<p>数据中台从技术的层面承接了数据湖的技术，通过数据技术，对海量、多源、多样的数据进行采集、处理、存储、计算，同时统一标准和口径，把数据统一之后，以标准形式存储，形成大数据资产层，以满足前台数据分析和应用的需求。</p>
<p>数据湖更强调应用，离业务更近，强调服务于前台的能力，实现逻辑、算法、标签、模型、数据资产的沉淀和复用，能更快速的相应业务和应用开发的需求，可追溯，更精准。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2022/01/13/1.1Hive%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/13/1.1Hive%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-13 20:33:04 / 修改时间：20:31:54" itemprop="dateCreated datePublished" datetime="2022-01-13T20:33:04+08:00">2022-01-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h2 id="Hive表相关介绍"><a href="#Hive表相关介绍" class="headerlink" title="Hive表相关介绍"></a>Hive表相关介绍</h2><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p>Hive会为每个创建的数据库在HDFS上创建一个目录，该数据库的表会以子目录形式存储，表中的数据会以表目录下的文件形式存储。对于default数据库，默认的缺省数据库没有自己的目录，default数据库下的表默认存放在/user/hive/warehouse目录下。</p>
<p><strong>（1）textfile</strong> </p>
<p>textfile为默认格式，存储方式为行存储。数据不做压缩，磁盘开销大，数据解析开销大。 </p>
<p>（2）SequenceFile </p>
<p>SequenceFile是Hadoop API提供的一种二进制文件支持，其具有使用方便、可分割、可压缩的特点。 </p>
<p>SequenceFile支持三种压缩选择：NONE, RECORD, BLOCK。 Record压缩率低，一般建议使用BLOCK压缩。 </p>
<p>（3）RCFile </p>
<p>一种行列存储相结合的存储方式。 </p>
<p>（4）ORCFile </p>
<p>数据按照行分块，每个块按照列存储，其中每个块都存储有一个索引。hive给出的新格式，属于RCFILE的升级版,性能有大幅度提升,而且数据可以压缩存储,压缩快 快速列存取。 </p>
<p><strong>（5）Parquet</strong> </p>
<p>Parquet也是一种行式存储，同时具有很好的压缩性能；同时可以减少大量的表扫描和反序列化的时间。</p>
<h2 id="DDL操作"><a href="#DDL操作" class="headerlink" title="DDL操作"></a>DDL操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="*创建表"></a>*创建表</h3><h4 id="创建内部表"><a href="#创建内部表" class="headerlink" title="创建内部表"></a>创建内部表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE page_view(</span><br><span class="line">     viewTime INT, </span><br><span class="line">     userid BIGINT,</span><br><span class="line">     page_url STRING, </span><br><span class="line">     referrer_url STRING,</span><br><span class="line">     ip STRING COMMENT &#x27;IP Address of the User&#x27;)</span><br><span class="line"> COMMENT &#x27;This is the page view table&#x27;</span><br><span class="line"> PARTITIONED BY(dt STRING, country STRING)</span><br><span class="line"> ROW FORMAT DELIMITED</span><br><span class="line">   FIELDS TERMINATED BY &#x27;\001&#x27;</span><br><span class="line">   COLLECTION ITEMS TERMINATED BY &#x27;\002&#x27;</span><br><span class="line">   MAP KEYS TERMINATED BY &#x27;\003&#x27;</span><br><span class="line"> STORED AS TEXTFILE;</span><br></pre></td></tr></table></figure>



<h4 id="创建外部表"><a href="#创建外部表" class="headerlink" title="创建外部表"></a>创建外部表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE page_view(</span><br><span class="line">     viewTime INT, </span><br><span class="line">     userid BIGINT,</span><br><span class="line">     page_url STRING, </span><br><span class="line">     referrer_url STRING,</span><br><span class="line">     ip STRING COMMENT &#x27;IP Address of the User&#x27;,</span><br><span class="line">     country STRING COMMENT &#x27;country of origination&#x27;)</span><br><span class="line"> COMMENT &#x27;This is the staging page view table&#x27;</span><br><span class="line"> ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;\054&#x27;</span><br><span class="line"> STORED AS TEXTFILE</span><br><span class="line"> LOCATION &#x27;/user/hadoop/warehouse/page_view&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> student_ptn(</span><br><span class="line">		id <span class="type">int</span>, </span><br><span class="line">		name string, </span><br><span class="line">		sex string, </span><br><span class="line">		age <span class="type">int</span>,</span><br><span class="line">		department string)</span><br><span class="line">partitioned <span class="keyword">by</span> (city string)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;,&quot;</span><br><span class="line">location &quot;/hive/student_ptn&quot;;</span><br></pre></td></tr></table></figure>

<p>分区</p>
<p>分为静态分区、动态分区，主要区别在于静态分区需要手动指定，而动态分区是基于查询参数的位置去推断分区的名称，从而建立分区。总的来说就是，静态分区的列是在编译时期通过用户传递来决定的；动态分区只有在SQL执行时才能确定。</p>
<h4 id="使用CTAS创建表"><a href="#使用CTAS创建表" class="headerlink" title="使用CTAS创建表"></a>使用CTAS创建表</h4><p>作用： 就是从一个查询select创建表结构，包括只复制表结构和复制表结构+数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//复制表结构</span><br><span class="line">create table student_copy like student_ptn;</span><br><span class="line">//复制表结构和数据</span><br><span class="line">create table student_ctas as select * from student where id &lt; 95012;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>如果在table的前面没有加external关键字，那么复制出来的新表。无论如何都是内部表<br>如果在table的前面有加external关键字，那么复制出来的新表。无论如何都是外部表</p>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student rename to new_student;</span><br></pre></td></tr></table></figure>

<h4 id="修改表分区"><a href="#修改表分区" class="headerlink" title="修改表分区"></a>修改表分区</h4><p>修改分区，一般来说，都是指修改分区的数据存储目录。</p>
<p>在添加分区的时候，直接指定当前分区的数据存储目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student_ptn add if not exists partition(city=&#x27;beijing&#x27;) location &#x27;/student_ptn_beijing&#x27;;</span><br></pre></td></tr></table></figure>

<p>修改已经指定好的分区的数据存储目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student_ptn partition (city=&#x27;beijing&#x27;) set location &#x27;/student_ptn_beijing&#x27;;</span><br></pre></td></tr></table></figure>

<p>先的分区文件夹仍存在，但是在往分区添加数据时，只会添加到新的分区目录</p>
<h4 id="修改表列"><a href="#修改表列" class="headerlink" title="修改表列"></a>修改表列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//增加表字段	</span><br><span class="line">alter table new_student add columns (score int);</span><br><span class="line">//修改表字段定义</span><br><span class="line">alter table new_student change name new_name string;</span><br><span class="line">//修改字段分隔符</span><br><span class="line">alter table new_student set serdeproperties(&#x27;field.delim&#x27;=&#x27;\t&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="*删除表"></a>*删除表</h3><p>删除表会移除表的元数据和数据，而HDFS上的数据，如果配置了Trash，会移到.Trash/Current目录下。</p>
<p>删除外部表时，表中的数据不会被删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name;</span><br><span class="line">DROP TABLE IF EXISTS table_name;</span><br></pre></td></tr></table></figure>

<p>从表或者表分区删除所有行，不指定分区，将截断表中的所有分区，也可以一次指定多个分区，截断多个分区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE table_name;</span><br><span class="line">TRUNCATE TABLE table_name PARTITION (dt=&#x27;20080808&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="DML操作"><a href="#DML操作" class="headerlink" title="DML操作"></a>DML操作</h2><h3 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h3><h4 id="Load方式"><a href="#Load方式" class="headerlink" title="*Load方式"></a>*Load方式</h4><p>Hive Load语句不会在加载数据的时候做任何转换工作，而是纯粹的把数据文件复制/移动到Hive表对应的地址。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA [<span class="keyword">LOCAL</span>] INPATH <span class="string">&#x27;filepath&#x27;</span> [OVERWRITE] <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span> (partcol1<span class="operator">=</span>val1,partcol2<span class="operator">=</span>val2 ...)]</span><br></pre></td></tr></table></figure>

<ul>
<li>如果命令中带有LOCAL，说明从本地文件系统加载数据，文件路径可以是相对路径，也可以是绝对路径。在这种情况下，首先将文件从本地复制到hdfs相应的位置，然后移动到hive表格中，这个时候原始数据文件是存在于hive表之下的路径下。这一点我会专门写一篇关于hive外部表的相应博文。</li>
<li>如果命令中没有LOCAL，代表我们的数据是从hdfs中读取文件，这个时候如果我们使用的是内部表，相应的hdfs的原始文件会消失，进入到相应的表格中。</li>
<li>filepath 可以是一个相对路径，也可以是一个绝对路径。可以是一个文件，也可以是一个文件夹目录（这个时候文件夹下的所有文件都会被加载）<br>-命令中如果带有overwirte，代表加载数据之前会清空目标表格，否则就是追加的方式。</li>
</ul>
<h4 id="INSERT方式"><a href="#INSERT方式" class="headerlink" title="*INSERT方式"></a>*INSERT方式</h4><h5 id="简单结构插入"><a href="#简单结构插入" class="headerlink" title="简单结构插入"></a>简单结构插入</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE<span class="operator">/</span><span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span>(partcol1 <span class="operator">=</span> col1,partcol2 <span class="operator">=</span>col2…)] <span class="keyword">SELECT</span> _statement <span class="keyword">FROM</span>  _statement</span><br></pre></td></tr></table></figure>

<p>动态分区插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span>(partcol1 <span class="operator">=</span> col1,partcol2 <span class="operator">=</span><span class="string">&#x27;$&#123;col&#125;&#x27;</span>…)] <span class="keyword">SELECT</span> _statement <span class="keyword">FROM</span>  _statement</span><br></pre></td></tr></table></figure>

<h5 id="多重插入"><a href="#多重插入" class="headerlink" title="多重插入"></a>多重插入</h5><p>多表插入指的是在同一条语句中, 把读取的同一份元数据插入到不同的表中。只需要<strong>扫描一遍元数据</strong>即可完成所有表的插入操作, 效率很高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> t_x</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_dest <span class="keyword">partition</span>(p<span class="operator">=</span>’p1’)</span><br><span class="line"><span class="keyword">select</span> …… <span class="keyword">where</span> …….</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_dest <span class="keyword">partition</span>(p<span class="operator">=</span>’p2’)</span><br><span class="line"><span class="keyword">select</span> …… <span class="keyword">where</span> …….</span><br></pre></td></tr></table></figure>

<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>提供了丰富的SQL查询方式来分析存储在Hadoop 分布式文件系统中的数据，可以将结构化的数据文件映射为一张数据库表，并提供完整的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行，通过自己的SQL 去查询分析需要的内容，这套SQL 简称Hive SQL，使不熟悉mapreduce 的用户很方便的利用SQL 语言查询，汇总，分析数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] select_expr, select_expr, ...</span><br><span class="line"><span class="keyword">FROM</span> table_reference</span><br><span class="line">[<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> col_list [<span class="keyword">HAVING</span> <span class="keyword">condition</span>]]</span><br><span class="line">[CLUSTER <span class="keyword">BY</span> col_list]</span><br><span class="line">[DISTRIBUTE <span class="keyword">BY</span> col_list] [SORT <span class="keyword">BY</span><span class="operator">|</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">[LIMIT number]</span><br></pre></td></tr></table></figure>

<p>•使用ALL和DISTINCT选项区分对重复记录的处理。默认是ALL，表示查询所有记录。DISTINCT表示去掉重复的记录</p>
<p>•Where 条件</p>
<p>•类似我们传统SQL的where 条件</p>
<p>•目前支持 AND,OR ,0.9版本支持between</p>
<p>•IN, NOT IN</p>
<p>•不支持EXIST ,NOT EXIST</p>
<p>ORDER BY与SORT BY的不同</p>
<p>•ORDER BY 全局排序，只有一个Reduce任务</p>
<p>•SORT BY 只在本机做排序</p>
<h5 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h5><p>说明：对字符进行拼接、截取、去空格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">字符串长度函数：        length</span><br><span class="line">字符串反转函数：        reverse</span><br><span class="line">字符串连接函数：        concat;     concat(‘abc’,&#x27;def’,&#x27;gh’)-&gt;abcdefgh</span><br><span class="line">带分隔符字符串连接函数： concat_ws;  concat_ws(&#x27;,&#x27;,&#x27;abc&#x27;,&#x27;def&#x27;,&#x27;gh&#x27;)-&gt;abc,def,gh</span><br><span class="line">字符串截取函数：        substr,substring; substr(&#x27;abcde&#x27;,3); substring(&#x27;abcde&#x27;,3)</span><br><span class="line">字符串截取函数：        substr,substring  substr(&#x27;abcde&#x27;,3,2);substring(&#x27;abcde&#x27;,3,2)</span><br><span class="line">字符串转大写函数：      upper,ucase</span><br><span class="line">字符串转小写函数：      lower,lcase</span><br><span class="line">去空格函数：            trim; 去除字符串两边的空格; trim(&#x27; abc &#x27;)</span><br><span class="line">左边去空格函数：        ltrim</span><br><span class="line">右边去空格函数：        rtrim</span><br><span class="line">正则表达式替换函数：    regexp_replace; regexp_replace(string A, string B, string C); 将字符串A中的符合java正则表达式B的部分替换为C。</span><br><span class="line">							eg: regexp_replace(&#x27;foobar&#x27;, &#x27;oo|ar&#x27;, &#x27;&#x27;)-&gt;fb</span><br><span class="line">正则表达式解析函数：    regexp_extract; regexp_extract(string subject,string pattern,int index);将字符串subject按照pattern正则规则拆分返回index指定字符。</span><br><span class="line">							eg: regexp_extract(&#x27;foothebar&#x27;, &#x27;foo(.*?)(bar)&#x27;, 0)-&gt;foothebar</span><br><span class="line">								regexp_extract(&#x27;foothebar&#x27;, &#x27;foo(.*?)(bar)&#x27;, 1)-&gt;bar</span><br><span class="line">								regexp_extract(data_field,&#x27;.*?bgStart\\=([^&amp;]+)&#x27;,1) </span><br><span class="line">URL解析函数：           parse_url;  parse_url(string urlString, string partToExtract [, string keyToExtract]);</span><br><span class="line">							返回：URL中指定的部分。partToExtract的有效值为：HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO</span><br><span class="line">							eg: parse_url(&#x27;https://www.iteblog.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#x27;, &#x27;HOST&#x27;)-&gt;facebook.com</span><br><span class="line">								parse_url(&#x27;https://www.iteblog.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#x27;, &#x27;QUERY&#x27;, &#x27;k1&#x27;)-&gt;v1	</span><br><span class="line">json解析函数：          get_json_object;get_json_object(string json_string, string path); 解析json的字符串json_string,返回path指定的内容</span><br><span class="line">空格字符串函数：        space;  length(space(10)) -&gt; 10</span><br><span class="line">重复字符串函数：        repeat; repeat(&#x27;abc&#x27;,5)-&gt;abcabcabcabcabc</span><br><span class="line">首字符ascii函数：       ascii;  ascii(&#x27;abcde&#x27;)-&gt;97</span><br><span class="line">左补足函数：            lpad;   lpad(&#x27;abc&#x27;,10,&#x27;td&#x27;)-&gt;tdtdtdtabc</span><br><span class="line">右补足函数：            rpad</span><br><span class="line">分割字符串函数:         split;       split(&#x27;abtcdtef&#x27;,&#x27;t&#x27;)-&gt;[&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]; 返回值: array</span><br><span class="line">集合查找函数:           find_in_set; find_in_set(string str, string strList);  返回str在strlist第一次出现的位置，strlist是用逗号分割的字符串。</span><br><span class="line">							eg: find_in_set(&#x27;ab&#x27;,&#x27;ef,ab,de&#x27;)-&gt; 2</span><br><span class="line">								find_in_set(&#x27;at&#x27;,&#x27;ef,ab,de&#x27;)-&gt; 0</span><br></pre></td></tr></table></figure>



<h5 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">取整函数:         round;   round(double a);        返回值: BIGINT</span><br><span class="line">指定精度取整函数:  round;   round(double a, int d); 返回值: DOUBLE</span><br><span class="line">向下取整函数:     floor;   返回值: BIGINT</span><br><span class="line">向上取整函数:     ceil;    返回值: BIGINT</span><br><span class="line">向上取整函数: 	 ceiling; 与ceil功能相同;   返回值: BIGINT   </span><br><span class="line">                 银行家舍入法（1~4：舍，6~9：进，5-&gt;前位数是偶：舍，5-&gt;前位数是奇：进）；</span><br><span class="line">                 bround(2.5) = 2, bround(3.5) = 4.</span><br><span class="line">取随机数函数:     rand;    rand(),rand(int seed);  返回值: double</span><br><span class="line">自然指数函数:     exp;     返回值: double</span><br><span class="line">以10为底对数函数: log10;   返回值: double</span><br><span class="line">以2为底对数函数:  log2</span><br><span class="line">对数函数:         log;     log(double base, double a)</span><br><span class="line">幂运算函数:       pow;     pow(double a, double p)</span><br><span class="line">幂运算函数:       power;   与pow功能相同</span><br><span class="line">立方根函数:       cbrt(2)</span><br><span class="line">开平方函数:       sqrt</span><br><span class="line">数学常数e         e()</span><br><span class="line">数学常数pi        pi()</span><br><span class="line">阶乘函数:         factorial(2)</span><br><span class="line">二进制函数:       bin;   返回值: string  </span><br><span class="line">十六进制函数:     hex;   返回值: string</span><br><span class="line">反转十六进制函数: unhex</span><br><span class="line">进制转换函数:     conv</span><br><span class="line">绝对值函数:       abs;  返回值: double int</span><br><span class="line">正取余函数:       pmod; pmod(int a, int b),pmod(double a, double b); 返回值: int double</span><br><span class="line">正弦函数:         sin</span><br><span class="line">反正弦函数:       asin</span><br><span class="line">余弦函数:         cos</span><br><span class="line">反余弦函数:       acos</span><br><span class="line">正切值函数:       tan</span><br><span class="line">反正切值函数:     atan</span><br><span class="line">弧度值转换角度值: degrees(30)</span><br><span class="line">角度值转换弧度值: radians(30)</span><br><span class="line">符号函数：        sign(2); 如果a是正数则返回1.0，是负数则返回-1.</span><br><span class="line">positive函数:     positive; positive(int a), positive(double a); 返回值: int double,返回a</span><br><span class="line">negative函数:     negative; negative(int a), negative(double a); 返回值: int double,返回-a</span><br></pre></td></tr></table></figure>

<h5 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h5><p>说明：时间获取、格式化、2个时间相差、时间增加、时间减少</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UNIX时间戳转日期函数:       from_unixtime; 返回值:string;  from_unixtime(1323308943,&#x27;yyyyMMdd&#x27;)</span><br><span class="line">获取当前UNIX时间戳函数: 	   unix_timestamp;返回值: bigint; unix_timestamp()</span><br><span class="line">日期转UNIX时间戳函数:        unix_timestamp;返回值: bigint; unix_timestamp(&#x27;2011-12-07 13:01:03&#x27;)</span><br><span class="line">指定格式日期转UNIX时间戳函数: unix_timestamp;返回值: bigint; unix_timestamp(&#x27;20111207 13:01:03&#x27;,&#x27;yyyyMMdd HH:mm:ss&#x27;)</span><br><span class="line">日期时间转日期函数:         to_date;    返回值: string; to_date(&#x27;2011-12-08 10:03:01&#x27;)</span><br><span class="line">日期转年函数:               year;       返回值: int;    year(&#x27;2011-12-08 10:03:01&#x27;)</span><br><span class="line">日期转月函数:               month    </span><br><span class="line">日期转天函数:               day      </span><br><span class="line">日期转小时函数:             hour     </span><br><span class="line">日期转分钟函数:             minute   </span><br><span class="line">日期转秒函数:               second   </span><br><span class="line">日期转周函数:               weekofyear; 返回值: int;    weekofyear(&#x27;2019-01-01 10:03:01&#x27;);   返回日期在当前的周数。</span><br><span class="line">日期转天函数:               dayofmonth; 返回值: int;    weekofyear(&#x27;2019-01-01 10:03:01&#x27;);   返回日期在当前月的天数</span><br><span class="line">日期比较函数:               datediff;   返回值: int;    datediff(&#x27;2012-12-08&#x27;,&#x27;2012-05-09&#x27;); 返回结束日期减去开始日期的天数。</span><br><span class="line">日期增加函数:               date_add;   返回值: string; date_add(&#x27;2012-12-08&#x27;,10);           返回开始日期startdate增加days天后的日期。</span><br><span class="line">日期减少函数:               date_sub</span><br><span class="line">最后一天的日期：            last_day</span><br><span class="line">返回当前时间的下一个星期X所对应的日期: next_day(&#x27;2015-01-14&#x27;, &#x27;TU&#x27;) = 2015-01-20  以2015-01-14为开始时间，其下一个星期二所对应的日期为2015-01-20</span><br><span class="line">返回当前时间属性哪个季度： quarter(&#x27;2015-04-08&#x27;) = 2</span><br><span class="line">返回当前时间日期:         current_date</span><br><span class="line">返回当前时间戳:           current_timestamp</span><br><span class="line">添加月数：                add_months(&#x27;2017-02-10&#x27;, 2);</span><br></pre></td></tr></table></figure>

<h5 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h5><p> • 窗口函数与分析函数:<br>    •用于分区排序<br>    •动态Group By<br>    •Top N<br>    •累计计算<br>    •层次查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">•排序函数：</span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，相同值取不同序号，不存在序号跳跃</span><br><span class="line">	  <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，相同值取相同序号，存在序号跳跃，不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，相同值取相同序号，不存在序号跳跃，不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"></span><br><span class="line">•聚合函数：</span><br><span class="line"><span class="built_in">sum</span>()<span class="operator">/</span><span class="built_in">count</span>()<span class="operator">/</span><span class="built_in">max</span>()<span class="operator">/</span><span class="built_in">max</span>()<span class="operator">/</span><span class="built_in">min</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..)：取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，聚合函数计算</span><br><span class="line"></span><br><span class="line">•窗口函数：</span><br><span class="line"><span class="built_in">lag</span>(col,n,<span class="keyword">default</span>)    <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..)：取<span class="keyword">partition</span>分组后，查看当前行的上第n行,不指定<span class="keyword">default</span>为<span class="keyword">null</span>,指定为指定字段，不支持<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">lead</span>(col,n,<span class="keyword">default</span>)   <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..)：取<span class="keyword">partition</span>分组后，查看当前行的下第n行,不指定<span class="keyword">default</span>为<span class="keyword">null</span>,指定为指定字段，不支持<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">first_value</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，截止到当前行<span class="operator">|</span>所有行，第一个值 </span><br><span class="line"><span class="built_in">last_value</span>()  <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，截止到当前行<span class="operator">|</span>所有行，最后一个值  </span><br><span class="line"></span><br><span class="line">•其他函数</span><br><span class="line"><span class="built_in">cume_dist</span>()  计算结果相对位置<span class="operator">/</span>总行数,不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">percent_rank</span>() (相对位置<span class="number">-1</span>)<span class="operator">/</span>(总行数<span class="number">-1</span>),不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"><span class="built_in">percentile_disc</span>()</span><br><span class="line">percentile_count()</span><br><span class="line">ratio_to_report() 计算当前行在分组中所有行数值总和所占的比例</span><br><span class="line"><span class="built_in">ntile</span>(n)      <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> ..): 取<span class="keyword">partition</span>分组<span class="keyword">order</span> <span class="keyword">by</span>排序后，照顺序切分成n片，返回当前切片值，不支持窗口<span class="keyword">rows</span>从句</span><br><span class="line"></span><br><span class="line">•<span class="keyword">over</span>从句：使用<span class="keyword">partition</span> <span class="keyword">by</span>与<span class="keyword">order</span> <span class="keyword">by</span>语句，使用一个或者多个数据类型的分区或者排序列 </span><br><span class="line">注:<span class="keyword">partition</span>内更细的划分，可使用windows子句。常见子句为：</span><br><span class="line">			preceding：  往前</span><br><span class="line">			following：  往后</span><br><span class="line">			<span class="keyword">current</span> <span class="type">row</span>：当前行</span><br><span class="line">			unbounded：  无界限（起点或终点）</span><br><span class="line">			unbounded preceding：表示从前面的起点</span><br><span class="line">			unbounded following：表示到后面的终点</span><br><span class="line">	eg: <span class="built_in">sum</span>(col) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> .. <span class="keyword">order</span> <span class="keyword">by</span> .. <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>):当前行与前一行做聚合</span><br><span class="line"></span><br><span class="line">•窗口规范支持以下格式：窗口必须和<span class="keyword">order</span> <span class="keyword">by</span> 一起出现</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> [unbounded <span class="operator">|</span> num] preceding <span class="keyword">and</span> [unbounded <span class="operator">|</span> num] following  <span class="comment">--当前行+往前所有行|num行+往后所有行|num行</span></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> [unbounded <span class="operator">|</span> num] preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>                  <span class="comment">--当前行+往前所有行|num行</span></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span>                 <span class="keyword">and</span> [unbounded <span class="operator">|</span> num] following  <span class="comment">--当前行+往后所有行|num行</span></span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> [unbounded <span class="operator">|</span> num] preceding <span class="keyword">and</span> [num] preceding</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> [num] following <span class="keyword">and</span> [unbounded <span class="operator">|</span> num] following</span><br><span class="line"></span><br><span class="line">• <span class="keyword">order</span> <span class="keyword">by</span> 后面缺少窗口<span class="keyword">rows</span>从句条件，</span><br><span class="line">   窗口规范默认是 <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span></span><br><span class="line">• <span class="keyword">order</span> <span class="keyword">by</span> 和窗口<span class="keyword">rows</span>从句都缺失,    </span><br><span class="line">   窗口规范默认是 <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> unbounded following</span><br><span class="line">• <span class="keyword">over</span> 从句支持排序函数、lead、lag、<span class="built_in">ntile</span>(n) 函数，但是并不支持和窗口一起使用它们</span><br></pre></td></tr></table></figure>

<h5 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">If函数:      if; if(1=2,100,200)</span><br><span class="line">非空查找函数: COALESCE;  COALESCE(null,&#x27;100&#x27;,&#x27;50&#x27;)</span><br><span class="line">非空查找函数: NVL;       NVL(expr1,expr2)</span><br><span class="line">非空查找函数: NVL2;      NVL2(expr1,expr2, expr3); 第一个参数为空那么显示第二个参数的值，如果第一个参数的值不为空，则显示第三个参数的值。</span><br><span class="line">非空查找函数: NULLIF;    NULLIF(exp1,expr2);      如果exp1和exp2相等则返回空(NULL)，否则返回第一个值</span><br><span class="line">条件判断函数：CASE val when num1 then &#x27;str&#x27; end; case 100 when 50 then &#x27;tom&#x27; when 100 then &#x27;mary&#x27; else &#x27;tim&#x27; end</span><br><span class="line">条件判断函数：CASE when val=num1 then &#x27;str&#x27; end; case when 1=2 then &#x27;tom&#x27; when 2=2 then &#x27;mary&#x27; else &#x27;tim&#x27; end</span><br></pre></td></tr></table></figure>

<h5 id="其他常见函数"><a href="#其他常见函数" class="headerlink" title="其他常见函数"></a>其他常见函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">• explode函数: (一行转多行)将字段内复杂的数据拆分成多行, 常用来做行拆多行</span><br><span class="line">				eg: explode(array): 返回多行array中对应的元素。如explode(array(&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;)),返回:A\B\C三行</span><br><span class="line">					explode(map): 返回多行map键值对对应元素。如explode(map(1,&#x27;A&#x27;,2,&#x27;B&#x27;,3,&#x27;C&#x27;)),返回:</span><br><span class="line"></span><br><span class="line">• lateral view函数：(一行转多行)当表中某个字段的取值为列表或数组时，利用该函数和split、explode可以将一行拆分成多行</span><br><span class="line">				eg: select deal_id ,type ,sp </span><br><span class="line">					from deal_ppt_mark_log t </span><br><span class="line">					lateral view explode(split(t.sources,&#x27;,&#x27;))a as sp</span><br><span class="line">				行转多列可以认为多列是一个字段处理，多个转换之间lateral view不能有 &quot;，&quot; 分割开</span><br><span class="line">				SELECT MR_Longitude,MR_Latitude,b,MAX(a) </span><br><span class="line">				FROM</span><br><span class="line">				(</span><br><span class="line">					select a,b,</span><br><span class="line">						MR_Longitude * 360 *1.0/ 16777216 MR_Longitude,</span><br><span class="line">						MR_Latitude * 90 / 8388608 MR_Latitude</span><br><span class="line">					FROM etl_4g_mro_zte </span><br><span class="line">					lateral view explode(split(concat_ws(&#x27;,&#x27;,MR_LteScRSRP,MR_LteNcRSRP1,MR_LteNcRSRP2,),&#x27;,&#x27;)) r1 AS a             </span><br><span class="line">					-----没有&#x27;,&#x27;</span><br><span class="line">					lateral view explode(split(concat_ws(&#x27;,&#x27;,MR_LteScEarfcn,MR_LteNcEarfcn1,MR_LteNcEarfcn2),&#x27;,&#x27;)) f1 AS b</span><br><span class="line">				)</span><br><span class="line">				WHERE MR_Longitude IS NOT NULL </span><br><span class="line">				AND MR_Longitude &lt;&gt;&#x27;&#x27;</span><br><span class="line">				AND DAY=20170323;</span><br><span class="line">			</span><br><span class="line">• collect_set()/Collect_list()函数：(多行转一行),同组不同行合并成一行，collect_set/collect_set 去重/不去重，</span><br><span class="line">                                 常常搭配concat_ws()函数使用</span><br><span class="line">				eg: concat_ws(&#x27;,&#x27;,collect_list(cast(qty as string)))	</span><br><span class="line"></span><br><span class="line">• str_to_map函数：str_to_map(字符串参数, 分隔符1, 分隔符2),分隔符1将文本分成K-V对，分隔符2分割每个K-V对。</span><br><span class="line">				eg: str_to_map(concat_ws(&#x27;,&#x27;,collect_set(concat(stat_date,&#x27;:&#x27;,label_state))),&#x27;,&#x27;,&#x27;:&#x27;) </span><br><span class="line"></span><br><span class="line">• distribute by和sort by函数一起使用：ditribute by是控制map的输出在reducer是如何划分的</span><br><span class="line">				eg: select mid, money, name from store distribute by mid sort by mid asc, money asc;</span><br><span class="line">				    所有的mid相同的数据会被送到同一个reducer去处理，这就是因为指定了distribute by mid</span><br><span class="line">					distribute by必须要写在sort by之前</span><br><span class="line"></span><br><span class="line">• cluster by函数： cluster by的功能就是distribute by和sort by相结合</span><br><span class="line">				eg: select mid, money, name from store cluster by mid sort by money;</span><br><span class="line">				    注意被cluster by指定的列只能是降序，不能指定asc和desc。</span><br><span class="line"></span><br><span class="line">• grouping sets()/cube()/rollup()高级聚合函数:</span><br></pre></td></tr></table></figure>



<h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h4><p>Hive 只支持等值连接（equality joins）、外连接（outer joins）和（left semi joins）。 Hive 不支持所有非等值的连接，因为非等值连接非常难转化到 map/reduce 任务 </p>
<ul>
<li><p>LEFT，RIGHT和FULL OUTER关键字用于处理join中空记录的情况 </p>
</li>
<li><p>LEFT SEMI JOIN 是 IN/EXISTS 子查询的一种更高效的实现 </p>
</li>
<li><p>join 时，每次 map/reduce 任务的逻辑是这样的： reducer会缓存join序列中除了最后一个表的所有表的记录，再通过最后一个表将结果序列化到文件系统 </p>
</li>
<li><p>实践中，应该把最大的那个表写在最后</p>
</li>
</ul>
<p><strong>LEFT SEMI JOIN</strong></p>
<p>LEFT SEMI JOIN 的限制是，JOIN 子句中右边的表只能在 ON 子句中设置过滤条件，在 WHERE 子句、SELECT 子句或其他地方过滤都不行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.key, a.value </span><br><span class="line"> <span class="keyword">FROM</span> a </span><br><span class="line"> <span class="keyword">WHERE</span> a.key <span class="keyword">in</span> (<span class="keyword">SELECT</span> b.key <span class="keyword">FROM</span> B);</span><br><span class="line">可以被重写为：</span><br><span class="line"> <span class="keyword">SELECT</span> a.key, a.val </span><br><span class="line"> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> SEMI <span class="keyword">JOIN</span> b <span class="keyword">on</span> (a.key <span class="operator">=</span> b.key)</span><br></pre></td></tr></table></figure>

<p><strong>UNION ALL</strong></p>
<p>用来合并多个select的查询结果，需要保证select中字段须一致  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_statement <span class="keyword">UNION</span> <span class="keyword">ALL</span> select_statement <span class="keyword">UNION</span> <span class="keyword">ALL</span> select_statement ...</span><br></pre></td></tr></table></figure>

<h4 id="集合数据结构"><a href="#集合数据结构" class="headerlink" title="集合数据结构"></a>集合数据结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">•数组类型：array， 存放相同类型的数据集合，        如：array[int] 下标访问 </span><br><span class="line">•映射集合类型：map， 存放相同类型的k-v键值对集合，   如：members[&quot;father&quot;],map_keys(members),map_values(members)</span><br><span class="line">•结构体类型： struct，可存放不同类型的数据的集合，    如：struct&#123;name:STRING,age:INT&#125;.</span><br></pre></td></tr></table></figure>

<p>如本身数据以string格式存储，但内容为json格式，可使用get_json_object</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_json_object(param1,&quot;$.param2&quot;)</span><br><span class="line">#第一个参数填写json对象变量，第二个参数使用$表示json变量标识，然后用 . 或 [] 读取对象或数组；如果输入的json字符串无效，那么返回NULL。</span><br><span class="line">json_tuple(jsonstr,p1,p2,……pn)</span><br><span class="line">#json_tuple与get_json_object的用法很类似，唯一的区别是，json_tuple输入的是json字符串中的多个&quot;字段&quot;，返回一个元组，元组中的所有数据类型为string。</span><br></pre></td></tr></table></figure>



<h4 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h4><table>
<thead>
<tr>
<th>/</th>
<th>做为转义，即通常在”/“后面的字符不按原来意义解释，如/b/匹配字符”b”，当b前面加了反斜杆后//b/，转意为匹配一个单词的边界。对正则表达式功能字符的还原，如”<em>“匹配它前面元字符0次或多次，/a</em>/将匹配a,aa,aaa，加了”/“后，/a/<em>/将只匹配”a</em>“。</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配一个输入或一行的开头，/^a/匹配”an A”，而不匹配”An a”</td>
</tr>
<tr>
<td>$</td>
<td>匹配一个输入或一行的结尾，/a$/匹配”An a”，而不匹配”an A”</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa ?    匹配前面元字符0次或1次，/ba*</td>
</tr>
<tr>
<td>(x)</td>
<td>匹配x保存x在名为$1…$9的变量中</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配x或y</td>
</tr>
<tr>
<td>{n}</td>
<td>精确匹配n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配n次以上</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配n-m次[xyz]    字符集(character set)，匹配这个集合中的任一一个字符(或元字符)</td>
</tr>
<tr>
<td>[xyz]</td>
<td>匹配这个集合中的任意一个字符或元字符，[ ^xyz]表示不匹配这个集合中的任何一个字符</td>
</tr>
<tr>
<td>[/b]</td>
<td>匹配一个退格符</td>
</tr>
<tr>
<td>/b</td>
<td>匹配一个单词的边界</td>
</tr>
<tr>
<td>/B</td>
<td>匹配一个单词的非边界</td>
</tr>
<tr>
<td>/cX</td>
<td>这儿，X是一个控制符，//cM/匹配Ctrl-M</td>
</tr>
<tr>
<td>/d</td>
<td>匹配一个字数字符，//d/ = /[0-9]/</td>
</tr>
<tr>
<td>/D</td>
<td>匹配一个非字数字符，//D/ = /[^0-9]/</td>
</tr>
<tr>
<td>/n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>/r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td>/s</td>
<td>匹配一个空白字符，包括/n,/r,/f,/t,/v</td>
</tr>
<tr>
<td>/S</td>
<td>匹配一个非空白字符，等于/[^/n/f/r/t/v]/</td>
</tr>
<tr>
<td>/t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td>/v</td>
<td>匹配一个重直制表符</td>
</tr>
<tr>
<td>/w</td>
<td>匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[/w]匹配”$5.98”中的5，等于[a-zA-Z0-9]</td>
</tr>
<tr>
<td>/W</td>
<td>匹配一个不可以组成单词的字符，如[/W]匹配”$5.98”中的$，等于[^a-zA-Z0-9]</td>
</tr>
</tbody></table>
<h5 id="常见正则"><a href="#常见正则" class="headerlink" title="常见正则"></a>常见正则</h5><p><strong>日期相关</strong></p>
<p>日期格式：^\d{4}-\d{1,2}-\d{1,2}</p>
<p>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p>
<p>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p>
<p><strong>汉字</strong></p>
<p> 汉字：^[\u4e00-\u9fa5]{0,}$</p>
<p><strong>金额</strong></p>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="从SQL到HiveQL应转变的习惯"><a href="#从SQL到HiveQL应转变的习惯" class="headerlink" title="从SQL到HiveQL应转变的习惯"></a>从SQL到HiveQL应转变的习惯</h4><p>1、Hive不支持等值连接</p>
<p>SQL中对两表内联可以写成：</p>
<p>select * from dual a,dual b where a.key = b.key;</p>
<p>Hive中应为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dual a <span class="keyword">join</span> dual b <span class="keyword">on</span> a.key <span class="operator">=</span> b.key;</span><br></pre></td></tr></table></figure>

<p>而不是传统的格式：</p>
<p>SELECT t1.a1 as c1, t2.b1 as c2FROM t1, t2</p>
<p>WHERE t1.a2 = t2.b2</p>
<p>2、分号字符</p>
<p>分号是SQL语句结束标记，在HiveQL中也是，但是在HiveQL中，对分号的识别没有那么智慧，例如：</p>
<p><code>select concat(key,concat(&#39;;&#39;,key)) from dual;</code></p>
<p>但HiveQL在解析语句时提示：</p>
<p>FAILED: Parse Error: line 0:-1 mismatched input ‘<EOF>‘ expecting ) in function specification</EOF></p>
<p>解决的办法是，使用分号的八进制的ASCII码进行转义，那么上述语句应写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(key,concat(<span class="string">&#x27;\073&#x27;</span>,key)) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p><strong>3、IS [NOT] NULL</strong></p>
<p>SQL中null代表空值, 值得警惕的是, 在HiveQL中String类型的字段若是空(empty)字符串, 即长度为0, 那么对它进行IS NULL的判断结果是False，可以 使用如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> length(filed) <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>4、Hive不支持将数据插入现有的表或分区中，仅支持覆盖重写整个表，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> t1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2;</span><br></pre></td></tr></table></figure>

<p>5、Hive 的嵌套查询再必须给表起别名</p>
<p>如：          </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.column <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> dt <span class="operator">=</span> <span class="number">20180528</span>) a   <span class="keyword">group</span> <span class="keyword">by</span>   a.dt limit <span class="number">100</span>        </span><br></pre></td></tr></table></figure>

<p>6、当有两个分区时，在使用where语句查询的时候，必须将两个分区都写出来，如：</p>
<p>若表的分区有两个dt日期和hr小时，我们想选择20180608这一个分区的数据，则选择条件为where dt = 20180608 and hr&gt;= 0 </p>
<h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><h4 id="Hive表导"><a href="#Hive表导" class="headerlink" title="Hive表导"></a>Hive表导</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE [<span class="keyword">LOCAL</span>] DIRECTORY <span class="string">&#x27;/home/hadoop/output&#x27;</span> <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> testA;  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 直接执行sql</span><br><span class="line">./hive -e &quot;select * from testA&quot; &gt;&gt; /home/hadoop/output/testA.txt</span><br><span class="line"># 执行sql文件</span><br><span class="line">./hive -f /home/hadoop/output/sql.sql &gt;&gt; /home/hadoop/output/testB.txt  </span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2021/08/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">自动化测试平台实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-08-09 21:09:54 / 修改时间：21:31:23" itemprop="dateCreated datePublished" datetime="2021-08-09T21:09:54+08:00">2021-08-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先谈谈自动化测试，对于目前的测试行业，自动化测试已经作为一项基本的测试技能，而在自动化测试的三层金字塔中，接口测试自动化也是其中最为广泛、稳定的测试手段，同时也引发了另外一种思考，到底要不要做测试平台，想要的平台是什么样子的。本文结合个人对自动化测试的理解以及对于python相关的学习，介绍接口自动化测试平台的实践。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2021/06/19/%E7%BC%BA%E9%99%B7%E4%B8%A5%E9%87%8D%E7%AD%89%E7%BA%A7%E5%AE%9A%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/19/%E7%BC%BA%E9%99%B7%E4%B8%A5%E9%87%8D%E7%AD%89%E7%BA%A7%E5%AE%9A%E4%B9%89/" class="post-title-link" itemprop="url">缺陷严重等级定义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-19 23:12:18 / 修改时间：23:16:43" itemprop="dateCreated datePublished" datetime="2021-06-19T23:12:18+08:00">2021-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>缺陷严重等级是指缺陷引起的故障对产品的影响程度；缺陷严重等级是根据其表现出的现象及影响面进行评估而定义的，等级可分为致命、严重、中等、轻微。 </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/19/%E7%BC%BA%E9%99%B7%E4%B8%A5%E9%87%8D%E7%AD%89%E7%BA%A7%E5%AE%9A%E4%B9%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2021/06/19/Metersphere%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/19/Metersphere%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Metersphere学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-19 19:59:11 / 修改时间：21:08:11" itemprop="dateCreated datePublished" datetime="2021-06-19T19:59:11+08:00">2021-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id><a href="#" class="headerlink" title></a></h3><p>1、获取安装包报错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@zcding metersphere]# curl -sSL https://github.com/metersphere/metersphere/releases/latest/download/quick_start.sh | sh</span><br><span class="line"></span><br><span class="line">--2021-06-20 07:29:15--  https://github.com/metersphere/metersphere/releases/latest/download/metersphere-release-v1.10.2.tar.gz</span><br><span class="line">Resolving github.com (github.com)... 140.82.112.4</span><br><span class="line">Connecting to github.com (github.com)|140.82.112.4|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... No data received.</span><br><span class="line">Retrying.</span><br><span class="line"></span><br><span class="line">--2021-06-20 07:29:32--  (try: 2)  https://github.com/metersphere/metersphere/releases/latest/download/metersphere-release-v1.10.2.tar.gz</span><br><span class="line">Connecting to github.com (github.com)|140.82.112.4|:443... failed: Connection refused.</span><br><span class="line">Resolving github.com (github.com)... 140.82.112.4</span><br><span class="line">Connecting to github.com (github.com)|140.82.112.4|:443... failed: Connection refused.</span><br><span class="line">tar (child): metersphere-release-v1.10.2.tar.gz: Cannot open: No such file or directory</span><br><span class="line">tar (child): Error is not recoverable: exiting now</span><br><span class="line">tar: Child returned status 2</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br><span class="line">sh: line 15: cd: metersphere-release-v1.10.2: No such file or directory</span><br><span class="line">sed: can&#x27;t read install.conf: No such file or directory</span><br><span class="line">sed: can&#x27;t read install.conf: No such file or directory</span><br><span class="line">/bin/bash: install.sh: No such file or directory</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>2、安装后服务无法连接</p>
<p>解决方案：</p>
<p>a. 查看镜像状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># msctl status</span><br><span class="line">### 返回结果</span><br><span class="line">       Name                     Command                       State                               Ports                     </span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">kafka                /opt/bitnami/scripts/kafka ...   Up (health: starting)   0.0.0.0:19092-&gt;19092/tcp, 9092/tcp            </span><br><span class="line">ms-data-streaming    /deployments/run-java.sh         Up (healthy)            0.0.0.0:8084-&gt;8084/tcp, 0.0.0.0:8085-&gt;8085/tcp</span><br><span class="line">ms-node-controller   /deployments/run-java.sh         Exit 1                                                                </span><br><span class="line">ms-prometheus        /bin/prometheus --config.f ...   Up (healthy)            0.0.0.0:9090-&gt;9090/tcp                        </span><br><span class="line">ms-server            /deployments/run-java.sh         Exit 1                                                                </span><br><span class="line">mysql                docker-entrypoint.sh mysqld      Exit 0                                                                </span><br><span class="line">nodeexporter         /bin/node_exporter --path. ...   Exit 2                                                                </span><br><span class="line">zookeeper            /opt/bitnami/scripts/zooke ...   Exit 143    </span><br></pre></td></tr></table></figure>

<p>镜像处于exit 1状态。查看服务器seliunx状态，并关闭seliunx。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改seliunx</span><br><span class="line"># vi /etc/sysconfig/selinux</span><br><span class="line"># 修改配置为</span><br><span class="line"># SELINUX=disabled</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>

<p>重启镜像服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl restart docker</span><br><span class="line"># msctl status</span><br></pre></td></tr></table></figure>

<p><img src="/./Metersphere%E5%AD%A6%E4%B9%A0/%E5%90%AF%E5%8A%A8%E7%8A%B6%E6%80%81.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2021/06/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95-vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95-vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">从零开始学习测试-vmware虚拟机与主机共享网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-19 18:57:07 / 修改时间：21:27:31" itemprop="dateCreated datePublished" datetime="2021-06-19T18:57:07+08:00">2021-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>vmware 虚拟机与主机网络互通方法有好多种，这里介绍最为常用的也是最方便的一种方法：NAT网络共享方法 。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95-vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2021/06/01/Docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/01/Docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">Docker学习之路-Docker基本概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-01 12:07:42" itemprop="dateCreated datePublished" datetime="2021-06-01T12:07:42+08:00">2021-06-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-20 22:56:42" itemprop="dateModified" datetime="2021-06-20T22:56:42+08:00">2021-06-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Docker包括三个基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>操作系统分为<strong>内核</strong>和<strong>用户空间</strong>。以Linux系统为例，内核启动后，会挂载root文件系统为其提供用户空间支持。而<strong>Docker镜像</strong>，就相当于是一个root文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）。</p>
<p><strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</strong></p>
<p><strong>分层存储</strong></p>
<p>这是容器化中一个比较重要的概念。镜像并不是常规意义上的ISO的打包文件，他是一个虚拟的概念，其实际体现并非由一个文件系统组成，而是由一组文件系统组成。镜像构建时，会一层层构建，前一层是后一层的基础，每一层在构建完之后就不会再发生改变。这个可以在容器的概念进行理解。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>镜像和容器的关系，就像面向对象程序设计的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>你可以把他理解为进程，但与直接在宿主机运行的集成不同，容器是在属于自己的独立的命名空间内运行。容器可以拥有自己的root文件系统、网络配置、进程空间等，运行在一个隔离的环境里。</p>
<p>每一个容器在运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，这个为容器运行时读写而准备的存储层为<strong>容器存储层。</strong>容器存储层的生命周期和容器一样，容器消亡时，容器存储层也随之小时，任何存储在容器存储层的信息都会随容器删除、重启而丢失。</p>
<p>按照<strong>Docker最佳实践</strong>的要求容器不应该向其存储层内写入任何数据，容器存储层要保持<strong>无状态化</strong>。所有的文件写入操作，都应该使用数据卷或者绑定宿主目录。后续我们也会讲到使用统一配置中心、统一日志中心来解决容器的配置以及程序日志读写问题。</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>镜像构建完成后，可以在当前宿主机上运行，但如果需要在其他服务器上使用这个镜像，就需要一个集中的存储、分发镜像的服务，就是镜像仓库。</p>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>todo</p>
<p>目前使用的事centos，配置国内的yum源进行安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 卸载旧版本Docker</span><br><span class="line">yum remove docker</span><br><span class="line"># 安装docker</span><br><span class="line">yum list |grep docker</span><br><span class="line">yum install -y docker.x86_64</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2021/05/23/%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA1-%E5%9F%BA%E4%BA%8E%E4%B8%9A%E5%8A%A1%E9%A3%8E%E9%99%A9%E8%A6%86%E7%9B%96%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA1-%E5%9F%BA%E4%BA%8E%E4%B8%9A%E5%8A%A1%E9%A3%8E%E9%99%A9%E8%A6%86%E7%9B%96%E5%BA%A6/" class="post-title-link" itemprop="url">用例设计方法论1-基于业务风险覆盖度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-23 22:39:55" itemprop="dateCreated datePublished" datetime="2021-05-23T22:39:55+08:00">2021-05-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-24 00:01:00" itemprop="dateModified" datetime="2021-05-24T00:01:00+08:00">2021-05-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">测试设计方法论</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“你们的测试开发比是多少？”</p>
<p>“测试用例覆盖度大概多少？这么多功能，怎么样区分测试用例的优先级呢？”</p>
<p>这是测试人员经常被问到的问题，怎么样在仅有的测试资源下，尽可能的保障产品质量？首先，我们需要明确一个事实：对于软件系统，全覆盖测试是一个几乎不可能的选择。这就意味着要有所取舍。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/05/23/%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA1-%E5%9F%BA%E4%BA%8E%E4%B8%9A%E5%8A%A1%E9%A3%8E%E9%99%A9%E8%A6%86%E7%9B%96%E5%BA%A6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zazing.github.io/2021/03/19/APM%E5%88%9D%E8%AE%A4%E7%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcding">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zazing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/19/APM%E5%88%9D%E8%AE%A4%E7%9F%A5/" class="post-title-link" itemprop="url">APM初认知</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-19 13:23:53" itemprop="dateCreated datePublished" datetime="2021-03-19T13:23:53+08:00">2021-03-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-20 00:05:41" itemprop="dateModified" datetime="2021-06-20T00:05:41+08:00">2021-06-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>随着微服务架构的流行，一次请求往往需要涉及到多个服务，因此服务性能监控和排查就变得更复杂：</p>
<ul>
<li>不同的服务可能由不同的团队开发、甚至可能使用不同的编程语言来实现</li>
<li>服务有可能布在了几千台服务器，横跨多个不同的数据中心</li>
</ul>
<p>作为测试人员，如何在架构、链路复杂的系统中，提早发现性能风险，有效定位性能问题，需要有一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题，这就是APM系统，全称是（<strong>A</strong>pplication <strong>P</strong>erformance <strong>M</strong>onitor，当然也有叫 <strong>A</strong>pplication <strong>P</strong>erformance <strong>M</strong>anagement tools）</p>
<p>由于工作的关系，接触到<a target="_blank" rel="noopener" href="https://github.com/apache/skywalking">Skywalking</a>APM平台，对于其架构、能力，以及对测试工作的帮助有了一定的体验。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/19/APM%E5%88%9D%E8%AE%A4%E7%9F%A5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zcding</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
